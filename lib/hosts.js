import dns from 'dns';
import fs from 'fs';

export const retry = async (fn, n) => {
  for (let i = 0; i < n; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === n - 1) {
        // propagate the last error to caller in most cases; callers may handle
        throw error;
      }
    }
  }
  return { failed: true };
};

export const getHostConfig = async (domain, lookupFn = dns.promises.lookup, retries = 3) => {
  const getConfig = async () => {
    const response = await lookupFn(domain);
    // lookupFn is expected to return { address }
    return { domain, ip: response && response.address ? response.address : '' };
  };

  try {
    const config = await retry(getConfig, retries);
    if (config && config.failed) {
      return { domain, ip: '' };
    }
    return config;
  } catch (error) {
    // on error (e.g., lookup throws even after retries) return empty ip
    return { domain, ip: '' };
  }
};

export const resolveUrls = async (domains, lookupFn = dns.promises.lookup) => {
  const promises = domains.map((d) => getHostConfig(d, lookupFn));
  return Promise.all(promises);
};

export const generateHosts = (configs) => {
  let hostStr = "# Generated by Github Hosts start \n\n";
  configs.forEach((i) => {
    const ipLen = i.ip ? i.ip.length : 0;
    const whiteLen = Math.max(1, 16 - ipLen);
    if (!i.ip) {
      hostStr += `# ${i.domain} update failed\n`;
    } else {
      hostStr += `${i.ip} ${" ".repeat(whiteLen)} ${i.domain}\n`;
    }
  });
  const updateTime = new Date().toLocaleString('en-US', { timeZone: 'Asia/shanghai' });
  hostStr += `\n# Last update: ${updateTime}\n`;
  return { hostStr, updateTime };
};

export const writeHosts = (hosts) => {
  try {
    const { hostStr, updateTime } = generateHosts(hosts);
    const template = fs.readFileSync('./README.template.md', 'utf-8');
    const nextReadme = template
      .toString()
      .replace('{{hosts}}', hostStr)
      .replace('{{last_update_time}}', updateTime);

    fs.writeFileSync('./hosts', hostStr);
    fs.writeFileSync('./README.md', nextReadme);

    return true;
  } catch (error) {
    throw error;
  }
};

export const generateRsc = (configs, listName = 'github-list') => {
  const header = '# Auto-generated MikroTik address list â€“ GitHub IPs\n';
  const prefix = '/ip firewall address-list\n';

  const seen = new Set();
  const lines = [];
  configs.forEach(({ ip }) => {
    if (!ip) return;
    if (seen.has(ip)) return;
    seen.add(ip);
    const isIPv6 = ip.includes(':');
    const suffix = isIPv6 ? '/128' : '/32';
    lines.push(`add address=${ip}${suffix} list=${listName}`);
  });

  return header + prefix + lines.join('\n') + '\n';
};

export const generateMdnsHosts = (configs) => {
  let out = '# Auto-generated Github address list\n';
  configs.forEach(({ domain, ip }) => {
    if (!ip) {
      out += `# ${domain} resolution failed\n`;
    } else {
      out += `${domain} ${ip}\n`;
    }
  });
  return out;
};

export const writeAdditionalFiles = (configs) => {
  try {
    const rsc = generateRsc(configs);
    fs.writeFileSync('./github-ip-list.rsc', rsc);

    const mdns = generateMdnsHosts(configs);
    fs.writeFileSync('./hosts.mdns', mdns);

    return true;
  } catch (err) {
    throw err;
  }
};
