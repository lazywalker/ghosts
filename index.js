import dns from "dns";
import fs from "fs";
import { urls as domains } from "./constants.js";

/**
 * Retries an asynchronous function multiple times until it succeeds
 * @param {Function} fn - The async function to retry
 * @param {number} n - Maximum number of retry attempts
 * @returns {Promise<{failed: boolean}|*>} Result of the function or {failed: true} if all attempts fail
 */
const retry = async (fn, n) => {
  for (let i = 0; i < n; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === n - 1) {
        console.error(`All ${n} retry attempts failed:`, error);
      }
    }
  }
  return {
    failed: true,
  };
};

/**
 * Resolves a domain name to its IP address with retry mechanism
 * @param {string} domain - The domain name to resolve
 * @returns {Promise<{domain: string, ip: string}>} Object containing domain and resolved IP
 */
const getHostConfig = async (domain) => {
  const getConfig = async () => {
    const response = await dns.promises.lookup(domain);
    return { domain, ip: response.address };
  };
  try {
    const config = await retry(getConfig, 3);
    if (config.failed) {
      console.warn(`Failed to resolve domain: ${domain}`);
      return { domain, ip: "" };
    }
    return config;
  } catch (error) {
    console.error(`Unexpected error resolving ${domain}:`, error);
    return { domain, ip: "" };
  }
};

/**
 * Resolves all domain names in parallel
 * @returns {Promise<Array<{domain: string, ip: string}>>} Array of resolved domain configs
 */
const resolveUrls = async () => {
  const promises = domains.map(getHostConfig);
  return Promise.all(promises);
};

/**
 * Generates hosts file content from resolved configurations
 * @param {Array<{domain: string, ip: string}>} configs - Array of domain configurations
 * @returns {{hostStr: string, updateTime: string}} Generated hosts content and update timestamp
 */
const generateHosts = (configs) => {
  let hostStr = "# Generated by Github Hosts start \n\n";
  configs.forEach((i) => {
    const whiteLen = 16 - i.ip.length;
    if (!i.ip) {
      hostStr += `# ${i.domain} update failed\n`;
    } else {
      hostStr += `${i.ip} ${" ".repeat(whiteLen)} ${i.domain}\n`;
    }
  });
  const updateTime = new Date().toLocaleString("en-US", {
    timeZone: "Asia/shanghai",
  });
  hostStr += `\n# Last update: ${updateTime}\n`;
  return {
    hostStr,
    updateTime,
  };
};

/**
 * Writes the generated hosts content to files and updates README files
 * @param {Array<{domain: string, ip: string}>} hosts - Array of resolved host configurations
 * @throws {Error} If file operations fail
 */
const writeHosts = (hosts) => {
  try {
    const { hostStr, updateTime } = generateHosts(hosts);
    const template = fs.readFileSync("./README.template.md", "utf-8");
    const nextReadme = template
      .toString()
      .replace("{{hosts}}", hostStr)
      .replace("{{last_update_time}}", updateTime);
    
    fs.writeFileSync("./hosts", hostStr);
    fs.writeFileSync("./README.md", nextReadme);
    
    console.log('Successfully updated hosts and README files');
  } catch (error) {
    console.error('Failed to write files:', error);
    throw error;
  }
};

/**
 * Generate a MikroTik .rsc address-list file content.
 * Each IP will be written as an address entry. IPv4 addresses get /32 and IPv6 get /128.
 * @param {Array<{domain: string, ip: string}>} configs
 * @param {string} listName - name of the address list in MikroTik (default: github-list)
 * @returns {string} .rsc file content
 */
const generateRsc = (configs, listName = "github-list") => {
  const header = "# Auto-generated MikroTik address list â€“ GitHub IPs\n";
  const prefix = "/ip firewall address-list\n";

  // deduplicate IPs and skip empty values
  const seen = new Set();
  const lines = [];
  configs.forEach(({ ip }) => {
    if (!ip) return;
    if (seen.has(ip)) return;
    seen.add(ip);
    // determine CIDR suffix
    const isIPv6 = ip.includes(":");
    const suffix = isIPv6 ? "/128" : "/32";
    lines.push(`add address=${ip}${suffix} list=${listName}`);
  });

  return header + prefix + lines.join("\n") + "\n";
};

/**
 * Generate a mosdns hosts-formatted file where each line is `domain ip`.
 * @param {Array<{domain: string, ip: string}>} configs
 * @returns {string}
 */
const generateMdnsHosts = (configs) => {
  let out = "# Auto-generated Github address list\n";
  configs.forEach(({ domain, ip }) => {
    if (!ip) {
      out += `# ${domain} resolution failed\n`;
    } else {
      out += `${domain} ${ip}\n`;
    }
  });
  return out;
};

/**
 * Write additional generated files: github-ip-list.rsc and hosts.mdns
 * @param {Array<{domain: string, ip: string}>} configs
 */
const writeAdditionalFiles = (configs) => {
  try {
    const rsc = generateRsc(configs);
    fs.writeFileSync("./github-ip-list.rsc", rsc);

    const mdns = generateMdnsHosts(configs);
    fs.writeFileSync("./hosts.mdns", mdns);

    console.log('Successfully updated github-ip-list.rsc and hosts.mdns');
  } catch (err) {
    console.error('Failed to write additional files:', err);
    throw err;
  }
};

/**
 * Main entry point for the application
 * Resolves domain names and updates hosts file
 */
const main = async () => {
  try {
    console.log('Starting hosts file update process...');
    const configs = await resolveUrls();
    await writeHosts(configs);
    writeAdditionalFiles(configs);
    console.log('Hosts file update completed successfully');
  } catch (error) {
    console.error('Failed to update hosts file:', error);
    process.exit(1);
  }
};

// Execute the main function
main();
